// Code generated by MockGen. DO NOT EDIT.
// Source: CheckLoginAttempt.go

// Package mocks is a generated GoMock package.
package mocks

import (
	constants "github.com/Rototot/anti-brute-force/pkg/domain/constants"
	entities "github.com/Rototot/anti-brute-force/pkg/domain/entities"
	gomock "github.com/golang/mock/gomock"
	net "net"
	reflect "reflect"
)

// MockbucketFactory is a mock of bucketFactory interface
type MockbucketFactory struct {
	ctrl     *gomock.Controller
	recorder *MockbucketFactoryMockRecorder
}

// MockbucketFactoryMockRecorder is the mock recorder for MockbucketFactory
type MockbucketFactoryMockRecorder struct {
	mock *MockbucketFactory
}

// NewMockbucketFactory creates a new mock instance
func NewMockbucketFactory(ctrl *gomock.Controller) *MockbucketFactory {
	mock := &MockbucketFactory{ctrl: ctrl}
	mock.recorder = &MockbucketFactoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockbucketFactory) EXPECT() *MockbucketFactoryMockRecorder {
	return m.recorder
}

// Create mocks base method
func (m *MockbucketFactory) Create(bType constants.BucketType) (*entities.Bucket, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateWhitelist", bType)
	ret0, _ := ret[0].(*entities.Bucket)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Create indicates an expected call of Create
func (mr *MockbucketFactoryMockRecorder) Create(bType interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateWhitelist", reflect.TypeOf((*MockbucketFactory)(nil).Create), bType)
}

// MockipGuard is a mock of ipGuard interface
type MockipGuard struct {
	ctrl     *gomock.Controller
	recorder *MockipGuardMockRecorder
}

// MockipGuardMockRecorder is the mock recorder for MockipGuard
type MockipGuardMockRecorder struct {
	mock *MockipGuard
}

// NewMockipGuard creates a new mock instance
func NewMockipGuard(ctrl *gomock.Controller) *MockipGuard {
	mock := &MockipGuard{ctrl: ctrl}
	mock.recorder = &MockipGuardMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockipGuard) EXPECT() *MockipGuardMockRecorder {
	return m.recorder
}

// HasAccess mocks base method
func (m *MockipGuard) HasAccess(ip net.IP) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasAccess", ip)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HasAccess indicates an expected call of HasAccess
func (mr *MockipGuardMockRecorder) HasAccess(ip interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasAccess", reflect.TypeOf((*MockipGuard)(nil).HasAccess), ip)
}

// MockrateLimiter is a mock of rateLimiter interface
type MockrateLimiter struct {
	ctrl     *gomock.Controller
	recorder *MockrateLimiterMockRecorder
}

// MockrateLimiterMockRecorder is the mock recorder for MockrateLimiter
type MockrateLimiterMockRecorder struct {
	mock *MockrateLimiter
}

// NewMockrateLimiter creates a new mock instance
func NewMockrateLimiter(ctrl *gomock.Controller) *MockrateLimiter {
	mock := &MockrateLimiter{ctrl: ctrl}
	mock.recorder = &MockrateLimiterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockrateLimiter) EXPECT() *MockrateLimiterMockRecorder {
	return m.recorder
}

// IsLimitExceeded mocks base method
func (m *MockrateLimiter) IsLimitExceeded(bucket *entities.Bucket) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsLimitExceeded", bucket)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsLimitExceeded indicates an expected call of IsLimitExceeded
func (mr *MockrateLimiterMockRecorder) IsLimitExceeded(bucket interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsLimitExceeded", reflect.TypeOf((*MockrateLimiter)(nil).IsLimitExceeded), bucket)
}
